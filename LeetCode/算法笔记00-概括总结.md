# LeetCode 算法笔记00-概括总结

程序 = 数据结构 + 算法

数据结构 包含 逻辑结构（集合、线性[数组、链表、栈、队列、hash表]、树形[二叉树等]、图形[无向、有向、连通图]）和物理结构（顺序存储、链式存储）

算法 需要衡量 时间复杂度T(n)=O(f(n)) 和 空间复杂度S(n)=O(f(n))

## 数据结构
### 链表
链接点类=元素值val+下一元素的地址（后继指针next）<br/>
（**循环**：先想好逻辑内容，写内部循环+迭代变换：while内循环及迭代移动node_j；while外由再套while将node_i值赋予node_j,并迭代移动node_i或其他;node_i位置改变则将头部给新变量head保留）<br/>
（递归：先if 递归的结束 return短序列 然后 每次递归处理的内容 最后 return 调用自身函数）<br/>
（**递归**：写出对每个元素做什么样的处理，到什么时候停(内部return)，处理后的元素同样进行这样操作则调自身函数）
链表排序法：<br/>
1. 冒泡排序(相邻两两比较)：内为 节点j相邻两两对比 移动至尾端，外为 (×无法前移只能node_i后移)i后移 至头部节点i的下一个到尾，保留head<br/>
2. 选择排序(最左和所有比较)：内为 节点i与节点j对比，j从i的下一个移动至尾端，外为 节点i 每次向后移一个 至i下一个不存在<br/>
3. 插入排序(左1和最左的已排序列比较并插入进去)：内为 最左节点i 按大小插入已排序列node_j中 至j从头head移动至尾，外为节点i 向后移一个 至末尾 <br/>
4. 归并排序(用递归实现一分为二至只剩单节点，合并左右比较再相连)<br/>
5. 快速排序(用递归实现选一基准并分离其他为大或小至单节点，合并这三项)<br/>
6. 计数排序(第一轮找到最大&小值构造列表，第二轮将所有元素对应列表项计数)<br/>
7. 桶排序(第一轮找最大最小值算桶的个数，第二轮根据大小将所有元素放入不同桶中，用各排序法对每个桶单独排序)<br/>
8. 基数排序(构建0-9数字桶共10个，第一轮将所有元素按个位数装桶中，按顺序取出并排序，然后按十位数装桶中，取出并排序...)

## 堆栈与单调栈
顺序存储(用列表append来添加元素，top指针对应栈顶跟着往后移动)或链式存储(用栈表示，top指针在链头，链头的它的.next往后对应了整条链)

## 深度优先搜索DFS
针对图结构<br/>
1. 基于递归：访问标记当前节点和其子节点，for对当前节点的所有子节点 递归 
2. 基于堆栈：内循环为 如果有子节点则访问，并将根节点放栈中 外循环为 取出栈顶元素，访问其邻居节点放栈中 至栈取空

## 队列
顺序存储(用列表对头为list[0]队尾为list[n],队头出队尾入)链式存储(出队队头为链头部往后.next是整条链，入队队尾为.next增加新元素)

## 广度优先搜索BFS
针对图结构<br/>
1. 基于队列：内循环为 兄弟节点入队列，外循环为队头出队并访问，遍历根节点的所有子节点

## 拓扑排序


## 算法







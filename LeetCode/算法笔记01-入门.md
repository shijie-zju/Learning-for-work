# LeetCode 算法笔记01-入门
## 一.基础概念
算法 + 数据结构 = 程序<br/>
### 数据结构
「数据结构」是数据的组织结构，用来组织、存储数据。<br>
按照数据的 「逻辑结构」 和 「物理结构」 来进行分类。
1. 数据的逻辑结构

集合结构：数据元素之间的相互关系，每个数据元素都是唯一且无序的。<br/>
线性结构：数据元素之间是「一对一」关系，包括数组、链表，以及由它们衍生出来的栈、队列、哈希表。<br/>
树形结构：数据元素之间是「一对多」的层次关系。如二叉树、多叉树、字典树等<br/>
图形结构：数据元素之间是「多对多」的关系，由结点和边构成，如无向图、有向图、连通图等。
2. 数据的物理结构

计算机内有多种存储结构，采用最多的是这两种结构：「顺序存储结构」、「链式存储结构」。<br/>
**顺序存储结构**：将数据元素存放在一片地址**连续的存储单元**里，数据元素之间的逻辑关系通过数据元素的存储地址来直接反映。<br/>
**链式存储结构**：将数据元素存放在任意的存储单元里，存储单元可以连续，也可以不连续。链式存储结构中，一般将每个数据元素占用的若干单元的组合称为一个链结点。每个链结点不仅要存放一个数据元素的数据信息，还要存放一个指出这个数据元素在逻辑关系的直接后继元素所在链结点的地址，该地址被称为指针。换句话说，数据元素之间的逻辑关系是通过指针来间接反映的。<br/>
这种结构的优点是：存储空间不必事先分配，在需要存储空间的时候可以临时申请，不会造成空间的浪费；一些操作的时间效率远比顺序存储结构高（插入、移动、删除元素）。缺点是：不仅数据元素本身的数据信息要占用存储空间，指针也需要占用存储空间，链式存储结构比顺序存储结构的空间开销大。

### 算法
「算法」 指的就是解决问题的方法。<br/>
算法的基本特性：输入、输出、有穷性、确定性、可行性<br/>
算法追求的目标：<br/>
运行时间更少（时间复杂度低）、占用内存更小（空间复杂度低）<br/>
正确性，可读性（方便后期修改调试），健壮性（对非法数据有较好的处理）<br/>

### 算法复杂度
「算法复杂度」是在问题的输入规模为n(一般为元素数量)的条件下，程序的时间使用情况和空间使用情况。<br/>
比较方法：事后统计（测一个程序）或预先估算<br/>
1. 时间复杂度

在问题的输入规模为n的条件下，算法运行所需要花费的时间，可以记作为T(n)<br/>
将基本操作次数(基本操作 ：算法执行中的每一条语句，每一次基本操作都可在常数时间内完成)作为度量标准<br/>
例如
```commandline
def algorithm(n):
    fact = 1
    for i in range(1, n + 1):
        fact *= i
    return fact
```
所有语句执行次数f(n)=1+n+n+1=2×n+2<br/>
时间复杂度T(n)=O(f(n)) ,其中O是一种渐进符号(专门刻画函数增长速度，只保留最高阶幂)<br/>
#### 时间复杂度计算
1.找出算法中基本操作（执行最多的语句，同城在循环中）<br/>
2.计算基本语句执行次数的数量级，保证最高次幂即可<br/>
加法原则：总的时间复杂度等于量级最大的基本语句的时间复杂度<br/>
乘法原则：循环嵌套代码复杂度=嵌套内外基本语句时间复杂度的乘积<br/>
例如
```commandline
def permutations(arr, start, end):
    if start == end:
        print(arr)
        return
 
    for i in range(start, end):
        arr[i], arr[start] = arr[start], arr[i]
        permutations(arr, start + 1, end)
        arr[i], arr[start] = arr[start], arr[i]
```
上述代码为递归的方法，第一层for循环执行n次，第二层执行n-1次...因此算法复杂度O(n!)
```commandline
def algorithm(n):
    cnt = 1
    res = 0
    while cnt < n:
        cnt *= 2
        for i in range(n):
            res += 1
    return res
```
外层循环为2^x=n，即循环次数x为log2(n)，又根据内层循环时间复杂度为O(n),乘法原则总时间复杂度O(n×logn)<br/>
常规时间复杂度：O(logn)<O(n)<O(n×logn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)<br/>

最佳时间复杂度：每个输入规模下用时最短的输入所对应的时间复杂度。<br/>
最坏时间复杂度：每个输入规模下用时最长的输入所对应的时间复杂度。<br/>
平均时间复杂度：每个输入规模下所有可能的输入所对应的平均用时复杂度（随机输入下期望用时的复杂度）。<br/>

2. 空间复杂度

在问题的输入规模为n的条件下，算法所占用的空间大小，可以记作为S(N)。一般将 算法的辅助空间 作为衡量空间复杂度的标准。S(n)=O(f(n))<br/>
算法的空间复杂度更容易计算，主要包括「局部变量（算法范围内定义的变量）所占用的存储空间」和「系统为实现递归（如果算法是递归的话）所使用的堆栈空间」两个部分。<br/>
例如：
```commandline
def algorithm(n):
    a = 1
    b = 2
    res = a * b + n
    return res
```
上述代码中使用a、b、res这3个局部变量，其所占空间大小为常数阶，并不会随着问题规模n的在增大而增大，所以该算法的空间复杂度为O(1)
```commandline
def algorithm(n):
    if n <= 0:
        return 1
    return n * algorithm(n - 1)
```
上述代码采用了递归调用的方式。每次递归调用都占用了1个栈帧空间，总共调用了n次，所以该算法的空间复杂度为O(n)。

### LeetCode
推荐刷题顺序和目录如下：

1. 初级算法、2. 数组类算法、3. 数组和字符串、4. 链表类算法、5. 哈希表、6. 队列 & 栈、7. 递归、8. 二分查找、9. 二叉树、10. 中级算法、11. 高级算法、12. 算法面试题汇总。
# LeetCode 算法笔记03-基础算法

## 枚举
列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。在列举的过程中，既不能遗漏也不能重复。<br/>
采用枚举算法解题的一般思路如下：<br/>
1确定枚举对象、枚举范围和判断条件，并判断条件设立的正确性。<br/>
2一一枚举可能的情况，并验证是否是问题的解。<br/>
3考虑提高枚举算法的效率。<br/>
## 递归与分治
#### 递归
一种通过重复将原问题分解为同类的子问题而解决的方法。在绝大数编程语言中，可以通过在函数中再次调用函数自身的方式来实现递归。<br/>
递归的数学模型其实就是「数学归纳法」。<br/>
可以把阶乘函数的递归计算过程分为两个部分：<br/>
1先逐层向下调用自身，直到达到结束条件<br/>
2然后再向上逐层返回结果，直到返回原问题的解<br/>

递归的基本思想就是： 把规模大的问题不断分解为子问题来解决。 那么，在写递归的时候，我们可以按照这个思想来书写递归，具体步骤如下：<br/>
1写出递推公式：找到将原问题分解为子问题的规律，并且根据规律写出递推公式。<br/>
2明确终止条件：推敲出递归的终止条件，以及递归终止时的处理方法。<br/>
3将递推公式和终止条件翻译成代码：<br/>
    1定义递归函数（明确函数意义、传入参数、返回结果等）。<br/>
    2书写递归主体（提取重复的逻辑，缩小问题规模）。<br/>
    3明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）。<br/>
```commandline
def recursion(大规模问题):
    if 递归终止条件:
        递归终止时的处理方法
    
    return recursion(小规模问题)
```
#### 分治
「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。<br/>
简单来说，分治算法的基本思想就是： 把规模大的问题不断分解为子问题，使得问题规模减小到可以直接求解为止。<br/>
分治包括了：递归和迭代<br/>
使用分治算法解决问题主要分为3个步骤：<br/>
分解：把要解决的问题分解为成若干个规模较小、相对独立、与原问题形式相同的子问题。<br/>
求解：递归求解各个子问题。<br/>
合并：按照原问题的要求，将子问题的解逐层合并构成原问题的解。<br/>
```commandline
def divide_and_conquer(problems_n):             # problems_n 为问题规模
    if problems_n < d:                          # 当问题规模足够小时，直接解决该问题
        return solove()                         # 直接求解
    
    problems_k = divide(problems_n)             # 将问题分解为 k 个相同形式的子问题
    
    res = [0 for _ in range(k)]                 # res 用来保存 k 个子问题的解
    for problem_k in problems_k:
        res[i] = divide_and_conquer(problem_k)  # 递归的求解 k 个子问题
    
    ans = merge(res)                            # 合并 k 个子问题的解
    return ans                                  # 返回原问题的解
```
## 回溯
回溯算法采用了一种 「走不通就回退」 的算法思想。<br/>
回溯算法通常用简单的递归方法来实现，在进行回溯过程中更可能会出现两种情况：<br/>
找到一个可能存在的正确答案；<br/>
在尝试了所有可能的分布方法之后宣布该问题没有答案。<br/>
```commandline
res = []    # 存放所欲符合条件结果的集合
path = []   # 存放当前符合条件的结果
def backtracking(nums):             # nums 为选择元素列表
    if 遇到边界条件:                  # 说明找到了一组符合条件的结果
        res.append(path[:])         # 将当前符合条件的结果放入集合中
        return

    for i in range(len(nums)):      # 枚举可选元素列表
        path.append(nums[i])        # 选择元素
        backtracking(nums)          # 递归搜索
        path.pop()                  # 撤销选择

backtracking(nums)
```
## 贪心
一种在每次决策时，总是采取在当前状态下的最好选择，从而希望导致结果是最好或最优的算法。<br/>
贪心算法是一种改进的「分步解决算法」，其核心思想是：将求解过程分成「若干个步骤」，然后根据题意选择一种「度量标准」，每个步骤都应用「贪心原则」，选取当前状态下「最好 / 最优选择（局部最优解）」，并以此希望最后得出的结果也是「最好 / 最优结果（全局最优解）」。<br/>
换句话说，贪心算法不从整体最优上加以考虑，而是一步一步进行，每一步只以当前情况为基础，根据某个优化测度做出局部最优选择，从而省去了为找到最优解要穷举所有可能所必须耗费的大量时间。<br/>

## 位运算
在计算机内部，数是以「二进制（Binary）」的形式来进行存储。位运算就是直接对数的二进制进行计算操作，在程序中使用位运算进行操作，会大大提高程序的性能。<br/>
#### 二进制数的转换
二进制转十进制：1010(2)=1×2^3+0×2^2+1×2^1+0×2^0<br/>
十进制转二进制：除二取余，逆序排列
#### 位运算基础操作
在二进制的基础上，我们可以对二进制数进行相应的位运算。基本的位运算共有6种，分别是：「按位与运算」、「按位或运算」、「按位异或运算」、「取反运算」、「左移运算」、「右移运算」。<br/>
按位与运算（AND）：按位与运算符为 &。其功能是对两个二进制数的每一个二进位进行与运算。1&1=0 1&0=0<br/>
按位或运算（OR）：按位或运算符为 |。其功能对两个二进制数的每一个二进位进行或运算。1|1=1 1|0=1 0|0=0<br/>
按位异或运算（XOR）：按位异或运算符为 ^。其功能是对两个二进制数的每一个二进位进行异或运算。1^0=1 1^1=0<br/>
取反运算（NOT）：取反运算符为 ~。其功能是对一个二进制数的每一个二进位进行取反运算。~1=0 ~0=1<br/>
左移运算（SHL）： 左移运算符为 <<。其功能是对一个二进制数的各个二进位全部左移若干位（高位丢弃，低位补0）。0100->1000<br/>
右移运算（SHR）： 右移运算符为 >>。其功能是对一个二进制数的各个二进位全部右移若干位（低位丢弃，高位补0）。0100->0010<br/>

## 动态规划DP
### 动态规划基础与记忆化搜索>

### 线性动态规划

### 背包问题

### 区间DP和树形DP

### 状压DP、计数DP和数位DP

